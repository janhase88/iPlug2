<plan>
  <Goal>Refactor, tidy, harden, and speed up the Windows Skia–Vulkan rendering path while respecting environment limits (Linux container: cannot build or run Windows binaries or GPU-backed Vulkan surfaces).</Goal>
  <context>
    Environment: Ubuntu-based container without Windows toolchain or Vulkan GPU access; can run cross-platform unit tests and static analysis that target extracted platform-agnostic logic only.
    Key areas: IGraphics/Platforms/IGraphicsWin.cpp, IGraphics/Drawing/IGraphicsSkia.cpp, Skia Win wrappers, any Vulkan swapchain helpers, Windows build scripts.
    Constraints: Do not attempt Windows compilation or runtime GPU tests; rely on code review, modularization, and host-agnostic tests/perf instrumentation.
  </context>
  <codingStyle>
    principles: SOTA, SSOT, SoC, DRY
    logging: verbose
    log_format: structured-json
    debug: everywhere
    tests: tdd
    coverage_min: 85
    errors: fail-fast
    docs: inline
    performance: optimize-critical-path
    ci: strict
    debug_paths: per-module switchable
  </codingStyle>
  <task>
    <name>t1_environment_scope_ready</name>
    <status>SUCCESS</status>
    <tryCount>1</tryCount>
    <curcialInfo>
      Action: Inventory available tooling, compilers, and scripts; confirm inability to execute Windows/Vulkan binaries; record feasible validation methods.
      Environment matrix: - OS: Linux 6.12.13 (uname -a). - Compilers: GCC 13.3.0 present; Clang unavailable (gcc --version, clang --version). - Build tools: CMake 3.28.3, Ninja 1.11.1 (cmake --version, ninja --version). - Scripting: Python 3.11.12 (python3 --version). - Windows toolchain: MSVC cl and MinGW cross-compilers absent (which cl, which x86_64-w64-mingw32-g++). - Vulkan tooling: vulkaninfo not installed, implying no GPU/Vulkan drivers (vulkaninfo).
      Feasible validation: host-side static analysis, Linux unit/integration tests via CMake/Ninja, log review.
      Prohibited operations: building/running Windows binaries, exercising Vulkan/Skia swapchains or HWND lifecycle in this container.
      Acceptance criteria met.
    </curcialInfo>
  </task>
  <task>
    <name>t2_codebase_intelligence_gathering</name>
    <status>SUCCESS</status>
    <tryCount>1</tryCount>
    <curcialInfo>
      Action: Map all Windows Skia–Vulkan code paths (render context creation, swapchain management, frame lifecycle) across IGraphicsSkia.cpp, IGraphicsWin.cpp, and auxiliary headers; capture dependencies and global/static state usage.
      Acceptance criteria: Curated reference of relevant functions, data flow, and current logging/error handling hotspots to feed into refactor design.
      Summary 2025-02-14: Windows Vulkan rendering splits responsibilities between IGraphicsWin (HWND/device bootstrap plus swapchain creation) and IGraphicsSkia (Skia-facing swapchain lifecycle). IGraphicsWin::OpenWindow() invokes CreateVulkanContext(), seeds VulkanContext with handles/sync primitives, and hands it to IGraphicsSkia::OnViewInitialized(), which caches the state. DrawResize()/BeginFrame()/EndFrame() orchestrate resizing, image acquisition, layout transitions, and presentation atop mutex-guarded state vectors/sets; they depend on IGraphicsWin::CreateOrResizeVulkanSwapchain() and share submission status via the returned flag. Current implementation leans on blocking waits (vkWaitForFences, vkDeviceWaitIdle) and repetitive command-pool setup, and logging remains plain DBGMSG text rather than structured-json, highlighting refactor targets for resilience, modularity, and observability.
    </curcialInfo>
    <tasks>
      <task>
        <name>t2_sub1_review_IGraphicsSkia</name>
        <status>SUCCESS</status>
        <tryCount>1</tryCount>
        <curcialInfo>
          Action: Read Vulkan-specific sections of IGraphics/Drawing/IGraphicsSkia.cpp (context creation, frame begin/end, surface management, cleanup).
          Acceptance criteria: Noted responsibilities, assumptions, and pain points (performance bottlenecks, global state, error handling gaps).
          Findings 2025-02-14: OnViewInitialized() consumes a VulkanContext from the platform layer and caches instance/device/surface/swapchain handles plus semaphores, fence, queue family, usage flags, and swapchain image array; DrawResize() is the resize/swapchain orchestration point, guarding mVKSwapchainMutex, flushing Skia, waiting on fences (with vkDeviceWaitIdle fallback), clearing debug tracking, querying surface caps, and calling IGraphicsWin::CreateOrResizeVulkanSwapchain() before rebuilding SkSurfaces; BeginFrame()/EndFrame() manage the full acquire → transition → draw → transition back lifecycle, with BeginFrame() acquiring the next image, creating/resetting command pools/buffers, tracking VkImageLayouts, and wrapping the VkImage into a GrBackendRenderTarget, while EndFrame() applies the reverse barrier and presents, updating mVKSubmissionPending.
          Observed pain points: Vulkan bookkeeping is tightly coupled to class members (mVKSwapchainImages, mVKImageLayouts, mVKDebugImages, mVKSubmissionPending, mVKSkipFrame, mVKSwapchainVersion/mVKFrameVersion) with duplicated command-pool allocation logic in both BeginFrame() and EndFrame(); resize and acquire paths repeatedly perform blocking waits (vkWaitForFences with UINT64_MAX, vkDeviceWaitIdle) which may stall; logging relies on DBGMSG text instead of structured-json; ReleaseSkiaGpuResources() invocation sits in DrawResize() but cleanup of Skia surfaces happens piecemeal across code paths.
        </curcialInfo>
      </task>
      <task>
        <name>t2_sub2_review_windows_platform_glue</name>
        <status>SUCCESS</status>
        <tryCount>1</tryCount>
        <curcialInfo>
          Action: Inspect Windows platform integration in IGraphics/Platforms/IGraphicsWin.cpp and related wrappers to understand how Vulkan/Skia surfaces are instantiated and tied to HWND lifecycle.
          Acceptance criteria: Documented sequence of calls and dependency expectations for swapchain recreation, resizing, and debug toggles.
          Findings 2025-02-14: OpenWindow() ensures SetPlatformContext(mPlugWnd), calls CreateVulkanContext(), and passes a populated VulkanContext (instance/device/surface/swapchain/queue family/semaphores/fence/vector pointer/format/usage flags) into OnViewInitialized(); CreateVulkanContext() builds the VkInstance (optionally enabling validation), chooses a VkPhysicalDevice via scoring with optional IGRAPHICS_VK_GPU preference, creates the logical device/queue, queries surface capabilities, seeds swapchain images by calling CreateOrResizeVulkanSwapchain(), and allocates synchronization primitives; DestroyVulkanContext() waits for device idle and resets swapchain/semaphore/fence holders; RecreateVulkanContext() tears down and rebuilds, reinvoking OnViewInitialized().
          Observed glue behavior: CreateOrResizeVulkanSwapchain() performs vkQueueWaitIdle/vkResetFences/vkQueueSubmit to synchronize the shared fence, queries capabilities/formats/present modes, recreates the swapchain, populates mVkSwapchainImages, and returns updated handles plus a submissionPending flag that feeds IGraphicsSkia; repeated failure paths aggressively call DestroyVulkanContext(), so error propagation currently collapses to a full teardown; logging again uses DBGMSG without structured metadata.
        </curcialInfo>
      </task>
      <task>
        <name>t2_sub3_dependency_and_build_script_scan</name>
        <status>SUCCESS</status>
        <tryCount>1</tryCount>
        <curcialInfo>
          Action: Review build scripts/configs for Windows Skia-Vulkan support to identify compile flags, optional modules, and potential refactor touchpoints.
          Acceptance criteria: List of build entry points requiring updates when refactoring modules or introducing new toggles.
          Findings 2025-02-14: common-win.props wires Vulkan SDK discovery—when VULKAN_SDK is set it injects include/library paths and the vulkan-1.lib dependency into Windows builds and appends those include directories to IGRAPHICS_INC_PATHS; Scripts/ci/build_project-win.yml rewrites per-project props files to switch the graphics macro set to IGRAPHICS_SKIA;IGRAPHICS_VULKAN for CI jobs; Documentation/SkiaVulkanWindows.md is the public activation guide, detailing prerequisite SDK setup and the need to define IGRAPHICS_SKIA;IGRAPHICS_VULKAN. Any refactor that renames modules, changes include roots, or adds new debug toggles will need matching updates in these entry points.
        </curcialInfo>
      </task>
    </tasks>
  </task>
  <task>
    <name>t3_refactor_strategy_design</name>
    <status>SUCCESS</status>
    <tryCount>1</tryCount>
    <curcialInfo>
      Action: Based on analysis, define modular architecture for Windows Skia–Vulkan path emphasizing SoC, fail-fast, structured logging, and switchable debug pathways per module.
      Acceptance criteria: Written design notes covering module boundaries, data flow, threading assumptions, logging schema, and how to enable unit testing of extracted logic on non-Windows hosts.
      Design 2025-02-14: The refactor pivots around a five-layer pipeline: (1) WinVkHostBridge (HWND/HINSTANCE lifecycle + DPI/resizing notifications), (2) VulkanDeviceCoordinator (instance/device/queue selection and lifetime with feature toggles captured in an immutable DeviceSnapshot), (3) SwapchainOrchestrator (capabilities queries, image allocation, reuse, and suboptimal/out-of-date handling), (4) SkiaSurfaceBinder (SkSurface/GrBackendRenderTarget wrapping + caching, with explicit ownership contracts), and (5) FrameScheduler (BeginFrame/EndFrame command sequencing, transition barriers, and submission tracking). Each layer exposes a narrow interface with explicit inputs/outputs so state flows unidirectionally from host -> device -> swapchain -> Skia -> frame loop, while telemetry/logging taps publish structured-json events at every boundary.
      Logging schema: Emit structured-json with keys module, phase, frameId, swapchainId, imageIndex, result, duration_ms, and hwndHash. Modules register via a central VkLogRouter that honors per-module debug toggles (e.g., kLogDevice, kLogSwapchain, kLogFrame) and downgrades verbosity unless DEBUG paths are enabled, satisfying SSOT for logging format.
      Testability strategy: All Vulkan entry points route through thin dispatch tables owned by VulkanDeviceCoordinator, enabling dependency injection of mock implementations on Linux. SwapchainOrchestrator and FrameScheduler operate on plain-old-data descriptors (DeviceSnapshot, SwapchainConfig, FrameActions) that can be fed into host-agnostic unit tests to verify state transitions, error propagation, and logging payloads without requiring a real HWND.
    </curcialInfo>
    <tasks>
      <task>
        <name>t3_sub1_define_module_boundaries</name>
        <status>SUCCESS</status>
        <tryCount>1</tryCount>
        <curcialInfo>
          Action: Propose separation of Vulkan resource management, Skia surface handling, and Windows window-system glue into distinct components/interfaces.
          Acceptance criteria: Draft interface definitions and responsibilities ensuring SSOT and debuggability.
          Result 2025-02-14: Proposed explicit interfaces—WinVkHostBridge (Initialize(hwnd, dpiConfig), PumpResize(width, height), Shutdown()) owns Win32 specifics and feeds a platform-agnostic VulkanBootParams struct; VulkanDeviceCoordinator (Create(bootParams), AcquireSnapshot(), Destroy()) encapsulates instance/device/queue selection and surfaces immutable DeviceSnapshot data (VK handles + dispatch tables + feature bits); SwapchainOrchestrator (EnsureSwapchain(snapshot, SwapchainConfig), AcquireNextImage(), PresentFrame()) owns VkSwapchainKHR creation/resizing, image vectors, and submission/fence bookkeeping; SkiaSurfaceBinder (WrapImage(imageInfo), PrepareSurface(imageIndex), ReleaseSurfaces()) handles GrBackendRenderTarget/SkSurface caching and clean teardown; FrameScheduler (BeginFrame(surfaceLease), RecordCommands(commandEncoder), EndFrame(presentInfo)) coordinates layout transitions and command buffers. Logging/control crosses modules via a shared VkLogRouter interface with module-scoped toggles.
        </curcialInfo>
      </task>
      <task>
        <name>t3_sub2_plan_performance_and_resilience_enhancements</name>
        <status>SUCCESS</status>
        <tryCount>1</tryCount>
        <curcialInfo>
          Action: Identify critical-path operations to optimize (e.g., swapchain re-use, command buffer submission) and outline hardening steps (error propagation, retry/fail-fast strategy, resource cleanup order).
          Acceptance criteria: Prioritized list of optimization/hardening actions with rationale and expected impact.
          Result 2025-02-14: Prioritized roadmap—(1) Promote per-frame fence waits to deadline-based waits with telemetry plus timeline semaphore support when available, falling back to targeted fence resets to avoid vkDeviceWaitIdle stalls (highest impact on frame pacing). (2) Persist command pools/primary command buffers per swapchain image and reset them lazily within FrameScheduler to eliminate redundant vkCreateCommandPool/vkAllocateCommandBuffers costs (cuts CPU overhead). (3) Cache VkImage layout/state in SwapchainOrchestrator and emit delta-driven barriers, reducing redundant vkCmdPipelineBarrier invocations. (4) Introduce typed Result enums with granular error codes and propagate them upward so WinVkHostBridge can decide between swapchain recreation and full context teardown, improving resilience. (5) Add guarded swapchain recreation retries with exponential backoff and structured logging, surfacing metrics to the VkLogRouter for diagnosis. (6) Ensure deterministic cleanup ordering via RAII wrappers around Vk objects so partial failures unwind safely without leaks.
        </curcialInfo>
      </task>
    </tasks>
  </task>
  <task>
    <name>t4_implement_modular_refactor</name>
    <status>SUCCESS</status>
    <tryCount>1</tryCount>
    <curcialInfo>
      Action: Apply code changes per design: extract modules, enforce SoC, add structured-json logging hooks, ensure per-module debug toggles, and clean up redundant state.
      Acceptance criteria: Updated source files compile (where possible), new modules are integrated without breaking existing interfaces, and logging/debug pathways match design.
      Result 2025-09-18: Completed the staged refactor—Skia surface caching, guarded logging macros, Win coordinator encapsulation, and build config updates have been integrated and validated via host-agnostic tests.
    </curcialInfo>
    <tasks>
      <task>
        <name>t4_sub1_extract_vulkan_resource_layer</name>
        <status>SUCCESS</status>
        <tryCount>1</tryCount>
        <curcialInfo>
          Action: Move Vulkan-specific resource creation/teardown into dedicated classes or functions with explicit lifetimes and fail-fast error handling.
          Acceptance criteria: Encapsulated Vulkan layer with minimal dependencies, structured error propagation, and inline docs.
          Result 2025-02-15: Introduced WinVulkanDeviceCoordinator inline module (WinVulkanDeviceCoordinator.h) to own VkInstance/VkSurface/VkPhysicalDevice/VkDevice selection with RAII teardown, preserving validation-layer negotiation and GPU preference scoring. Updated IGraphicsWin to drive CreateVulkanContext() through the coordinator, logging failures and delegating DestroyVulkanContext() cleanup to the encapsulated teardown while resetting swapchain state defaults.
        </curcialInfo>
      </task>
      <task>
        <name>t4_sub2_streamline_skia_surface_management</name>
        <status>SUCCESS</status>
        <tryCount>0</tryCount>
        <curcialInfo>
          Action: Refactor Skia surface/swapchain interaction to reduce redundant allocations, reuse framebuffers, and clarify ownership semantics.
          Result 2025-09-17: Cached per-image Skia surfaces with EnsureSwapchainSurface helper, centralized command buffer setup, and cleaned Vulkan resource reuse to eliminate redundant wraps while maintaining deterministic teardown.
          Acceptance criteria: Reduced redundant resource churn, deterministic cleanup, and improved clarity via inline documentation.
        </curcialInfo>
      </task>
      <task>
        <name>t4_sub3_integrate_debug_and_logging_controls</name>
        <status>SUCCESS</status>
        <tryCount>0</tryCount>
        <curcialInfo>
          Action: Implement structured-json logging, verbose debug switches per module, and ensure they are toggleable from single configuration headers or compile-time flags.
          Result 2025-09-17: Introduced VulkanLogging utility with configurable verbosity, migrated Windows and Skia Vulkan paths to structured JSON telemetry, and added swapchain diagnostics via centralized logging.
          Acceptance criteria: Logging statements cover critical paths, toggles documented, and defaults respect strict CI.
        </curcialInfo>
      </task>
      <task>
        <name>t4_sub4_cleanup_and_modernize_build_configs</name>
        <status>SUCCESS</status>
        <tryCount>0</tryCount>
        <curcialInfo>
          Action: Update Windows-specific build scripts/config files to accommodate new module structure without enabling Windows compilation in this environment.
          Result 2025-09-17: Added default IGRAPHICS_VULKAN_LOG_VERBOSITY macro to common-win.props to expose logging controls through build configuration.
          Acceptance criteria: Consistent configuration files with updated references and guarded debug switches.
        </curcialInfo>
      </task>
    </tasks>
  </task>
  <task>
    <name>t5_validation_and_testing_strategy</name>
    <status>SUCCESS</status>
    <tryCount>1</tryCount>
    <curcialInfo>
      Action: Devise and implement test coverage (unit or integration) for extracted logic that can run on Linux, plus document manual validation steps for Windows developers.
      Acceptance criteria: New automated tests achieving ≥85% coverage on touched logic where feasible, with documented gaps and manual validation plan for Windows-specific runtime behavior.
      Result 2025-09-18: Host-agnostic VulkanLogging tests compile and run under GCC (C++11/14/17) and the Windows validation playbook plus observability notes document the remaining manual checks.
    </curcialInfo>
    <tasks>
      <task>
        <name>t5_sub1_author_host_agnostic_tests</name>
        <status>SUCCESS</status>
        <tryCount>1</tryCount>
        <curcialInfo>
          Action: Write unit tests for refactored components that do not require actual Windows handles or Vulkan GPU, using mocks/stubs as needed.
          Acceptance criteria: Tests compile and run in Linux CI, covering critical decision logic and error paths.
          Result 2025-09-17: Added Tests/HostAgnostic/VulkanLoggingTests.cpp to validate JSON emission, escape rules, and macro routing through the overridable sink, compiled with g++ -std=c++17 and executed successfully in the container.
        </curcialInfo>
      </task>
      <task>
        <name>t5_sub2_define_windows_validation_playbook</name>
        <status>SUCCESS</status>
        <tryCount>1</tryCount>
        <curcialInfo>
          Action: Create documentation outlining steps for Windows developers to validate Vulkan rendering (build commands, debug toggles, perf measurement suggestions).
          Acceptance criteria: Clear checklist included in repo docs or inline comments for follow-up manual testing.
          Result 2025-09-18: Added a Windows validation playbook to Documentation/SkiaVulkanWindows.md covering rebuild guidance, verbosity toggles, log inspection, device-loss recovery, and artifact capture to aid manual verification.
        </curcialInfo>
      </task>
    </tasks>
  </task>
  <task>
    <name>t6_documentation_updates</name>
    <status>SUCCESS</status>
    <tryCount>1</tryCount>
    <curcialInfo>
      Action: Update inline docs/comments and any relevant markdown to explain new architecture, debug switches, and performance considerations.
      Acceptance criteria: Inline documentation matches new structure and meets inline docs requirement; README or platform notes updated if necessary.
      Result 2025-09-18: Added inline comments covering swap-chain surface caching and command buffer reuse and expanded the Windows guide with observability/debug-control notes for the new logging layer.
    </curcialInfo>
  </task>
  <task>
    <name>t7_post_refactor_quality_gate</name>
    <status>SUCCESS</status>
    <tryCount>1</tryCount>
    <curcialInfo>
      Action: Run applicable automated tests on Linux, perform static analysis or linting, and review structured logs for regressions.
      Acceptance criteria: Tests pass in this environment, CI alignment verified, and final notes capture pending manual checks for Windows users.
      Result 2025-09-18: Recompiled and executed the host-agnostic Vulkan logging tests under GCC with C++11/14/17 to ensure compatibility and confirmed logging output remains deterministic.
    </curcialInfo>
  </task>
</plan>
